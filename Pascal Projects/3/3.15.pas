program Speed;

var
  Eps, y, n, ind, sh1, sh2, sh3: real;
  i: integer;

begin
  read(Eps);
  i := 0;
  n := -1;
  y := 0;
  repeat
    begin
      i := i + 1;///Счетчик для определения знака следующего слагаемого
      n := n + 2;///Счетчик для определения знаменателя следующего слагаемого
      if (odd(i)) then ind := (1) else ind := (-1);///Если счетчик i нечетный то знак одночлена положительный
      y := y + ind * 4 / n;
    end;
  until abs(pi - y) <= Eps;///Сравнение с заданным эпсилон
  sh1 := i;
   {находим скорость сходимости для следущего разложения при том прежде чем использовать старые переменные, присвоим им исходные значения}
  
  i := 0;
  n := 0;
  y := 3;{3 - константа, по заданной формуле, n не влияет на него}
  repeat
    begin
      i := i + 1;
      n := n + 2;
      if odd(i) then ind := (1) else ind := (-1);
      y := y + ind * (4 / (n * (n + 1) * (n + 2)));
    end;
  until abs(pi - y) <= Eps;///Сравнение с заданным эпсилон
  sh2 := i;
  
  {Ещё раз обнулим все переменные}
  i := 0;
  n := 0;
  y := 3;
  ind := 0;///Теперь будем использовать эту переменную не для определения промежуточных значений выражения
  {Проверим следующее разложение}
  repeat
    begin
      i := i + 1;
      ind := ind + (1 / sqr(i));
      y := sqrt(6 * ind);
    end;
  until abs(pi - y) <= Eps;///Сравнение с заданным эпсилон
  sh3 := i;
  {найдём наиболее эффективное разложение числа Пи}
  if (sh1 < sh2) and (sh1 < sh3) then writeln('Первое разложение') else
  if (sh2 < sh1) and (sh2 < sh3) then writeln('Второе разложение') else
  if (sh3 < sh1) and (sh3 < sh2) then writeln('Второе разложение');
  writeln(sh1);
  writeln(sh2);
  writeln(sh3);
end.